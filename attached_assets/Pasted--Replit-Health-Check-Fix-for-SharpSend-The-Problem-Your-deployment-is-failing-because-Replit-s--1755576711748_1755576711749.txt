# Replit Health Check Fix for SharpSend

## The Problem
Your deployment is failing because Replit's health checker is hitting the `/` endpoint and expecting:
- A quick response (under 30 seconds)
- HTTP 200 status code
- No expensive operations

## Immediate Fix

### Step 1: Add a Fast Health Check Endpoint

Update your `server/index.js` to handle the root endpoint efficiently:

```javascript
// server/index.js
import express from 'express';
import path from 'path';

const app = express();
const PORT = process.env.PORT || 5000;

// CRITICAL: Add this BEFORE any expensive middleware or database operations
app.get('/', (req, res) => {
  // Fast health check response
  res.status(200).json({
    status: 'healthy',
    service: 'SharpSend',
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

// Add a dedicated health endpoint
app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'ok',
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    timestamp: new Date().toISOString()
  });
});

// Middleware setup (AFTER health check routes)
app.use(express.json());
app.use(express.static('dist/public'));

// Your other routes...
// app.use('/api', apiRoutes);

// Start server
app.listen(PORT, '0.0.0.0', () => {
  console.log(`🚀 Server running on port ${PORT}`);
  console.log(`📊 Environment: ${process.env.NODE_ENV || 'development'}`);
  
  // Move expensive operations AFTER server starts
  setTimeout(async () => {
    try {
      await initializeDatabase();
      console.log('✅ Database initialized');
    } catch (error) {
      console.error('❌ Database initialization failed:', error);
    }
  }, 1000);
});

async function initializeDatabase() {
  // Move your seeding logic here
  // This runs AFTER the server is responding to health checks
}
```

### Step 2: Move Database Operations Out of Startup

If you're doing database seeding on startup, move it to run after the server starts:

```javascript
// WRONG - This blocks health checks
app.listen(PORT, async () => {
  await seedDemoData(); // This can take too long!
  console.log('Server ready');
});

// CORRECT - Server starts immediately, seeding happens after
app.listen(PORT, '0.0.0.0', () => {
  console.log('🚀 Server ready for health checks');
  
  // Run expensive operations asynchronously
  setImmediate(async () => {
    try {
      await seedDemoData();
      console.log('✅ Demo data seeded');
    } catch (error) {
      console.error('❌ Seeding failed:', error);
      // Don't crash the server
    }
  });
});
```

### Step 3: Optimize Your React App Serving

Make sure your React app serving doesn't interfere with health checks:

```javascript
// Serve static files efficiently
app.use(express.static('dist/public', {
  maxAge: '1d', // Cache static assets
  etag: false   // Disable etag for faster responses
}));

// Catch-all for React Router (ONLY for non-API routes)
app.get('*', (req, res, next) => {
  // Skip API routes
  if (req.path.startsWith('/api/') || req.path.startsWith('/health')) {
    return next();
  }
  
  // Serve React app
  res.sendFile(path.join(process.cwd(), 'dist/public/index.html'));
});
```

## Quick Implementation

### Option A: Minimal Fix (2 minutes)

Add this at the very top of your server file, before any other routes:

```javascript
// Add this FIRST in your server/index.js
app.get('/', (req, res) => {
  res.status(200).send('OK');
});
```

### Option B: Better Fix (5 minutes)

```javascript
// server/index.js - Add at the top
const startTime = Date.now();

app.get('/', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    service: 'SharpSend',
    uptime: Date.now() - startTime,
    timestamp: new Date().toISOString()
  });
});

app.get('/health', async (req, res) => {
  try {
    // Optional: Quick database ping (keep it fast!)
    // await sql`SELECT 1`;
    
    res.status(200).json({
      status: 'healthy',
      database: 'connected',
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      environment: process.env.NODE_ENV
    });
  } catch (error) {
    res.status(503).json({
      status: 'unhealthy',
      error: error.message
    });
  }
});
```

## Common Issues and Solutions

### Issue 1: Database Connection Blocking Startup
```javascript
// WRONG
const sql = postgres(DATABASE_URL); // This might hang

app.listen(PORT, () => {
  console.log('Server started');
});

// CORRECT
let sql;

app.listen(PORT, () => {
  console.log('Server started');
  
  // Connect to database after server is ready
  setTimeout(() => {
    sql = postgres(DATABASE_URL);
  }, 100);
});
```

### Issue 2: Expensive Middleware
```javascript
// Move expensive middleware after health checks
app.get('/', (req, res) => res.send('OK'));
app.get('/health', (req, res) => res.json({ status: 'ok' }));

// Then add your middleware
app.use(expensiveMiddleware);
app.use('/api', apiRoutes);
```

### Issue 3: React Router Conflicts
```javascript
// Make sure health checks come BEFORE catch-all
app.get('/', healthCheck);
app.get('/health', detailedHealthCheck);
app.use('/api', apiRoutes);

// React catch-all LAST
app.get('*', serveReactApp);
```

## Testing Your Fix

### Local Testing
```bash
# Test health endpoint
curl http://localhost:5000/
curl http://localhost:5000/health

# Should respond quickly with 200 status
```

### Deployment Testing
```bash
# After deploying, test the live endpoint
curl https://your-app.replit.app/
curl https://your-app.replit.app/health
```

## Deploy the Fix

1. **Update your server file** with the health check endpoint
2. **Commit and push** your changes
3. **Redeploy** on Replit
4. **Monitor** the deployment logs for success

The health check should now pass and your deployment should succeed!


## Advanced Troubleshooting

### Debug Health Check Issues

Add logging to understand what's happening:

```javascript
// server/index.js
app.use((req, res, next) => {
  const start = Date.now();
  console.log(`📥 ${req.method} ${req.path} - ${req.ip}`);
  
  res.on('finish', () => {
    const duration = Date.now() - start;
    console.log(`📤 ${req.method} ${req.path} - ${res.statusCode} - ${duration}ms`);
  });
  
  next();
});

// Health check with detailed logging
app.get('/', (req, res) => {
  console.log('🏥 Health check requested');
  const response = {
    status: 'healthy',
    service: 'SharpSend',
    timestamp: new Date().toISOString(),
    pid: process.pid,
    uptime: process.uptime()
  };
  
  console.log('🏥 Health check response:', response);
  res.status(200).json(response);
});
```

### Performance Optimization

```javascript
// Optimize for fast responses
app.set('x-powered-by', false); // Remove unnecessary header
app.set('etag', false); // Disable etag generation

// Add response time header
app.use((req, res, next) => {
  const start = Date.now();
  res.on('finish', () => {
    res.set('X-Response-Time', `${Date.now() - start}ms`);
  });
  next();
});

// Fast health check with minimal processing
app.get('/', (req, res) => {
  res.set('Cache-Control', 'no-cache');
  res.status(200).send('OK');
});
```

### Database Health Check (Optional)

Only add this if you need to verify database connectivity:

```javascript
// server/utils/healthCheck.js
import { sql } from '../config/database.js';

let dbHealthy = true;
let lastDbCheck = 0;
const DB_CHECK_INTERVAL = 30000; // 30 seconds

export async function quickDbCheck() {
  const now = Date.now();
  
  // Cache result for 30 seconds to avoid repeated checks
  if (now - lastDbCheck < DB_CHECK_INTERVAL) {
    return dbHealthy;
  }
  
  try {
    // Very fast query
    await sql`SELECT 1`;
    dbHealthy = true;
    lastDbCheck = now;
    return true;
  } catch (error) {
    console.error('Database health check failed:', error.message);
    dbHealthy = false;
    lastDbCheck = now;
    return false;
  }
}

// Use in health endpoint
app.get('/health', async (req, res) => {
  const dbStatus = await quickDbCheck();
  
  res.status(dbStatus ? 200 : 503).json({
    status: dbStatus ? 'healthy' : 'unhealthy',
    database: dbStatus ? 'connected' : 'disconnected',
    uptime: process.uptime(),
    timestamp: new Date().toISOString()
  });
});
```

## Complete Server Template

Here's a complete server setup that handles health checks properly:

```javascript
// server/index.js
import express from 'express';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const app = express();
const PORT = process.env.PORT || 5000;
const startTime = Date.now();

// Disable unnecessary features for performance
app.set('x-powered-by', false);
app.set('etag', false);

// CRITICAL: Health checks FIRST (before any middleware)
app.get('/', (req, res) => {
  res.status(200).json({
    status: 'healthy',
    service: 'SharpSend',
    uptime: Date.now() - startTime,
    timestamp: new Date().toISOString(),
    environment: process.env.NODE_ENV || 'development'
  });
});

app.get('/health', (req, res) => {
  res.status(200).json({
    status: 'ok',
    uptime: process.uptime(),
    memory: {
      used: Math.round(process.memoryUsage().heapUsed / 1024 / 1024) + 'MB',
      total: Math.round(process.memoryUsage().heapTotal / 1024 / 1024) + 'MB'
    },
    timestamp: new Date().toISOString()
  });
});

// Basic middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// Serve static files
app.use(express.static(path.join(__dirname, '../dist/public'), {
  maxAge: '1d',
  etag: false
}));

// API routes
app.use('/api', (req, res, next) => {
  // Add API-specific middleware here
  next();
});

// Import and use your API routes
// import publishersRouter from './routes/publishers.js';
// app.use('/api/publishers', publishersRouter);

// React app catch-all (MUST be last)
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../dist/public/index.html'));
});

// Error handling
app.use((error, req, res, next) => {
  console.error('Server error:', error);
  res.status(500).json({
    error: 'Internal server error',
    message: process.env.NODE_ENV === 'development' ? error.message : 'Something went wrong'
  });
});

// Start server
const server = app.listen(PORT, '0.0.0.0', () => {
  console.log(`🚀 Server running on port ${PORT}`);
  console.log(`📊 Environment: ${process.env.NODE_ENV || 'development'}`);
  console.log(`🏥 Health check: http://localhost:${PORT}/`);
  
  // Initialize database and other services AFTER server starts
  initializeServices();
});

async function initializeServices() {
  try {
    // Add your initialization logic here
    // await initializeDatabase();
    // await seedDemoData();
    console.log('✅ Services initialized');
  } catch (error) {
    console.error('❌ Service initialization failed:', error);
    // Don't crash the server - health checks should still work
  }
}

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('🛑 SIGTERM received, shutting down gracefully');
  server.close(() => {
    console.log('✅ Server closed');
    process.exit(0);
  });
});

export default app;
```

## Replit-Specific Configuration

### Update .replit File

```toml
entrypoint = "server/index.js"
modules = ["nodejs-20"]

[deployment]
run = ["npm", "run", "build", "&&", "npm", "start"]
deploymentTarget = "cloudrun"

[deployment.env]
NODE_ENV = "production"

[run]
args = ["npm", "run", "dev"]

[run.env]
NODE_ENV = "development"
```

### Update package.json

```json
{
  "scripts": {
    "dev": "NODE_ENV=development nodemon server/index.js",
    "build": "vite build && esbuild server/index.ts --platform=node --packages=external --bundle --format=esm --outdir=dist",
    "start": "NODE_ENV=production node server/index.js",
    "health": "curl http://localhost:5000/health"
  }
}
```

## Monitoring After Deployment

### Check Health Status
```bash
# Test your deployed app
curl https://your-app.replit.app/
curl https://your-app.replit.app/health

# Should return 200 status quickly
```

### Monitor Logs
Watch your Replit deployment logs for:
- ✅ "Server running on port 5000"
- ✅ Health check requests returning 200
- ❌ Any timeout or error messages

## Summary

The key fixes are:
1. **Add fast health check endpoint at `/`**
2. **Move expensive operations after server startup**
3. **Ensure health checks respond quickly (< 30 seconds)**
4. **Return proper HTTP 200 status codes**

This should resolve your health check failures and get your deployment working!

