import { CustomerIoIntegrationService } from './customerio-integration';

interface UserInsight {
  userId: string;
  email: string;
  insights: {
    engagementPattern: string;
    devicePreference: string;
    contentPreference: string[];
    responseTimings: string;
    newsletterSubscriptions: string[];
    behaviorSummary: string;
  };
  tags: string[];
}

interface SegmentInsight {
  segmentId: string;
  name: string;
  memberCount: number;
  insights: {
    commonBehaviors: string[];
    deviceTrends: string;
    engagementPatterns: string;
    contentPreferences: string[];
    responseTiming: string;
    revenue: string;
    summary: string;
  };
  recommendations: string[];
}

interface AutoGeneratedSegment {
  name: string;
  description: string;
  criteria: any[];
  expectedSize: number;
  value: string;
  insights: string[];
}

export class AISegmentGenerator {
  private customerIO: CustomerIoIntegrationService;

  constructor(customerIOService: CustomerIoIntegrationService) {
    this.customerIO = customerIOService;
  }

  /**
   * Generate AI-powered insights for individual users
   */
  async generateUserInsights(userIds: string[]): Promise<UserInsight[]> {
    const insights: UserInsight[] = [];

    for (const userId of userIds) {
      try {
        // Get user data from Customer.io
        const userData = await this.getUserEngagementData(userId);
        
        const userInsight: UserInsight = {
          userId,
          email: userData.email || userId,
          insights: {
            engagementPattern: this.analyzeEngagementPattern(userData),
            devicePreference: this.analyzeDevicePreference(userData),
            contentPreference: this.analyzeContentPreference(userData),
            responseTimings: this.analyzeResponseTimings(userData),
            newsletterSubscriptions: this.analyzeNewsletterSubscriptions(userData),
            behaviorSummary: this.generateBehaviorSummary(userData)
          },
          tags: this.generateUserTags(userData)
        };

        insights.push(userInsight);
      } catch (error) {
        console.error(`Failed to generate insights for user ${userId}:`, error);
        
        // Provide basic insight even if data fetch fails
        insights.push({
          userId,
          email: userId,
          insights: {
            engagementPattern: "Data unavailable",
            devicePreference: "Unknown",
            contentPreference: [],
            responseTimings: "Unknown",
            newsletterSubscriptions: [],
            behaviorSummary: "Limited data available for analysis"
          },
          tags: ['needs_analysis']
        });
      }
    }

    return insights;
  }

  /**
   * Generate AI-powered insights for segments
   */
  async generateSegmentInsights(segmentIds: string[]): Promise<SegmentInsight[]> {
    const insights: SegmentInsight[] = [];

    for (const segmentId of segmentIds) {
      try {
        // Get segment members with their data
        const members = await this.customerIO.getSegmentMembersWithTags(segmentId);
        const memberData = await Promise.all(
          members.slice(0, 50).map(member => // Analyze up to 50 members for performance
            this.getUserEngagementData(member.id).catch(() => null)
          )
        );

        const validData = memberData.filter(data => data !== null);
        
        const segmentInsight: SegmentInsight = {
          segmentId,
          name: `Segment ${segmentId}`,
          memberCount: members.length,
          insights: {
            commonBehaviors: this.findCommonBehaviors(validData),
            deviceTrends: this.analyzeSegmentDeviceTrends(validData),
            engagementPatterns: this.analyzeSegmentEngagementPatterns(validData),
            contentPreferences: this.analyzeSegmentContentPreferences(validData),
            responseTiming: this.analyzeSegmentResponseTiming(validData),
            revenue: this.analyzeSegmentRevenue(validData),
            summary: this.generateSegmentSummary(validData, members.length)
          },
          recommendations: this.generateSegmentRecommendations(validData)
        };

        insights.push(segmentInsight);
      } catch (error) {
        console.error(`Failed to generate insights for segment ${segmentId}:`, error);
        
        insights.push({
          segmentId,
          name: `Segment ${segmentId}`,
          memberCount: 0,
          insights: {
            commonBehaviors: [],
            deviceTrends: "Data unavailable",
            engagementPatterns: "Unknown",
            contentPreferences: [],
            responseTiming: "Unknown",
            revenue: "Unknown",
            summary: "Limited data available for analysis"
          },
          recommendations: ['Collect more engagement data for better insights']
        });
      }
    }

    return insights;
  }

  /**
   * Automatically generate intelligent segments based on user behavior
   */
  async generateAISegments(): Promise<AutoGeneratedSegment[]> {
    try {
      // Get real subscribers from Customer.io for AI analysis
      let subscribers: any[] = [];
      
      try {
        const customerResponse = await this.customerIO.makeApiRequest('GET', '/customers?limit=100');
        const realSubscribers = customerResponse.results || [];
        
        // Use real Customer.io subscriber data
        subscribers = realSubscribers.map((customer: any) => ({
          id: customer.id || customer.email,
          email: customer.email,
          attributes: customer.attributes
        }));
        
        console.log(`Using ${subscribers.length} real Customer.io subscribers for AI analysis`);
        
        if (subscribers.length === 0) {
          console.warn('No real subscribers found, cannot generate AI segments');
          return [];
        }
      } catch (error) {
        console.error('Failed to fetch real Customer.io subscribers:', error);
        return [];
      }
      
      const subscriberData = await Promise.all(
        subscribers.slice(0, 100).map(sub => // Analyze first 100 for performance
          this.getUserEngagementData(sub.id).catch(() => null)
        )
      );

      const validData = subscriberData.filter(data => data !== null);
      
      const segments: AutoGeneratedSegment[] = [
        // High-Engagement Segments
        this.generateHighEngagementSegment(validData),
        this.generateMobileFirstSegment(validData),
        this.generateEarlyResponderSegment(validData),
        
        // Content-Based Segments
        this.generateTechEnthusiastSegment(validData),
        this.generateFinanceReaderSegment(validData),
        this.generateNewsJunkieSegment(validData),
        
        // Behavioral Segments
        this.generateWeekendReaderSegment(validData),
        this.generateClickerSegment(validData),
        this.generateLurkerSegment(validData),
        
        // Revenue Segments
        this.generateHighValueSegment(validData),
        this.generatePotentialUpgradeSegment(validData)
      ].filter(segment => segment.expectedSize > 0);

      return segments;
    } catch (error) {
      console.error('Failed to generate AI segments:', error);
      return [];
    }
  }

  // Helper methods for user analysis
  private async getUserEngagementData(userId: string): Promise<any> {
    try {
      // Fetch real engagement data from Customer.io tracking API
      const response = await this.customerIO.makeApiRequest('GET', `/customers/${userId}/attributes`);
      
      // Parse real Customer.io attributes for engagement analysis
      const attributes = response.customer?.attributes || {};
      
      return {
        id: userId,
        email: attributes.email || userId,
        opens: attributes.sharpsend_total_opens || 0,
        clicks: attributes.sharpsend_total_clicks || 0,
        deviceType: attributes.sharpsend_device_preference || 'unknown',
        avgResponseTime: attributes.sharpsend_avg_response_time || 24,
        contentCategories: this.parseContentPreferences(attributes),
        newsletters: this.parseNewsletterSubscriptions(attributes),
        revenue: attributes.sharpsend_lifetime_value || 0,
        joinDate: attributes.created_at ? new Date(attributes.created_at) : new Date(),
        engagementScore: attributes.sharpsend_engagement_score || 0,
        lastInteraction: attributes.sharpsend_last_interaction,
        tags: this.parseSharpSendTags(attributes)
      };
    } catch (error) {
      // If individual user data isn't available, return minimal real data structure
      console.warn(`Could not fetch engagement data for ${userId}, using minimal data`);
      return {
        id: userId,
        email: userId.includes('@') ? userId : `${userId}@unknown.com`,
        opens: 0,
        clicks: 0,
        deviceType: 'unknown',
        avgResponseTime: 24,
        contentCategories: [],
        newsletters: [],
        revenue: 0,
        joinDate: new Date(),
        engagementScore: 0,
        tags: []
      };
    }
  }

  private parseContentPreferences(attributes: any): string[] {
    const preferences = [];
    if (attributes.sharpsend_content_tech) preferences.push('tech');
    if (attributes.sharpsend_content_finance) preferences.push('finance');
    if (attributes.sharpsend_content_news) preferences.push('news');
    return preferences;
  }

  private parseNewsletterSubscriptions(attributes: any): string[] {
    const newsletters = [];
    if (attributes.newsletter_a_subscriber) newsletters.push('Newsletter A');
    if (attributes.newsletter_c_subscriber) newsletters.push('Newsletter C');
    return newsletters;
  }

  private parseSharpSendTags(attributes: any): string[] {
    const tags = [];
    
    // Extract tags from SharpSend tag attributes
    Object.keys(attributes).forEach(key => {
      if (key.startsWith('sharpsend_tag_') && attributes[key]) {
        const tagName = key.replace('sharpsend_tag_', '');
        tags.push(tagName);
      }
    });
    
    // Also check for tags array if available
    if (attributes.sharpsend_tags && Array.isArray(attributes.sharpsend_tags)) {
      tags.push(...attributes.sharpsend_tags);
    }
    
    return [...new Set(tags)]; // Remove duplicates
  }

  private analyzeEngagementPattern(userData: any): string {
    const openRate = userData.opens / 10; // Assuming 10 emails sent
    const clickRate = userData.clicks / userData.opens || 0;

    if (openRate > 0.8 && clickRate > 0.3) {
      return "Highly engaged - opens most emails and clicks frequently";
    } else if (openRate > 0.5 && clickRate > 0.1) {
      return "Moderately engaged - regular reader with occasional clicks";
    } else if (openRate > 0.3) {
      return "Selective reader - opens some emails but rarely clicks";
    } else {
      return "Low engagement - infrequent opener, may need re-engagement";
    }
  }

  private analyzeDevicePreference(userData: any): string {
    return userData.deviceType === 'mobile' ? 
      "Primarily mobile user - reads on phone/tablet" : 
      "Desktop user - prefers computer/laptop reading";
  }

  private analyzeContentPreference(userData: any): string[] {
    return userData.contentCategories.map((cat: string) => {
      switch (cat) {
        case 'tech': return 'Technology and innovation content';
        case 'finance': return 'Financial news and market analysis';
        case 'news': return 'Breaking news and current events';
        default: return cat;
      }
    });
  }

  private analyzeResponseTimings(userData: any): string {
    const avgHours = userData.avgResponseTime;
    if (avgHours < 2) {
      return "Immediate responder - engages within hours of email delivery";
    } else if (avgHours < 8) {
      return "Same-day responder - typically engages within 8 hours";
    } else if (avgHours < 24) {
      return "Daily responder - usually engages within 24 hours";
    } else {
      return "Delayed responder - takes more than a day to engage";
    }
  }

  private analyzeNewsletterSubscriptions(userData: any): string[] {
    return userData.newsletters || [];
  }

  private generateBehaviorSummary(userData: any): string {
    const patterns = [];
    
    if (userData.opens > 15) patterns.push("frequent email opener");
    if (userData.clicks > 5) patterns.push("active link clicker");
    if (userData.deviceType === 'mobile') patterns.push("mobile-first user");
    if (userData.avgResponseTime < 4) patterns.push("quick responder");
    if (userData.revenue > 500) patterns.push("high-value subscriber");
    
    return patterns.length > 0 ? 
      `This subscriber is a ${patterns.join(', ')}` :
      "Standard engagement profile";
  }

  private generateUserTags(userData: any): string[] {
    const tags = [];
    
    if (userData.opens > 15) tags.push('high_engagement');
    if (userData.clicks > 5) tags.push('active_clicker');
    if (userData.deviceType === 'mobile') tags.push('mobile_user');
    if (userData.avgResponseTime < 4) tags.push('quick_responder');
    if (userData.revenue > 500) tags.push('high_value');
    if (userData.contentCategories.includes('tech')) tags.push('tech_enthusiast');
    if (userData.contentCategories.includes('finance')) tags.push('finance_reader');
    
    return tags;
  }

  // Segment analysis methods
  private findCommonBehaviors(memberData: any[]): string[] {
    const behaviors = [];
    const mobileUsers = memberData.filter(m => m.deviceType === 'mobile').length;
    const highOpeners = memberData.filter(m => m.opens > 10).length;
    const quickResponders = memberData.filter(m => m.avgResponseTime < 4).length;
    
    if (mobileUsers > memberData.length * 0.6) {
      behaviors.push("Predominantly mobile users");
    }
    if (highOpeners > memberData.length * 0.5) {
      behaviors.push("High email engagement");
    }
    if (quickResponders > memberData.length * 0.4) {
      behaviors.push("Quick to respond to emails");
    }
    
    return behaviors;
  }

  private analyzeSegmentDeviceTrends(memberData: any[]): string {
    const mobileCount = memberData.filter(m => m.deviceType === 'mobile').length;
    const mobilePercent = Math.round((mobileCount / memberData.length) * 100);
    
    return `${mobilePercent}% mobile users, ${100 - mobilePercent}% desktop users`;
  }

  private analyzeSegmentEngagementPatterns(memberData: any[]): string {
    const avgOpens = memberData.reduce((sum, m) => sum + m.opens, 0) / memberData.length;
    const avgClicks = memberData.reduce((sum, m) => sum + m.clicks, 0) / memberData.length;
    
    return `Average ${Math.round(avgOpens)} opens, ${Math.round(avgClicks)} clicks per subscriber`;
  }

  private analyzeSegmentContentPreferences(memberData: any[]): string[] {
    const contentCounts: Record<string, number> = {};
    memberData.forEach(m => {
      m.contentCategories.forEach((cat: string) => {
        contentCounts[cat] = (contentCounts[cat] || 0) + 1;
      });
    });
    
    return Object.entries(contentCounts)
      .sort(([,a], [,b]) => b - a)
      .slice(0, 3)
      .map(([content, count]) => `${content} (${Math.round(count / memberData.length * 100)}%)`);
  }

  private analyzeSegmentResponseTiming(memberData: any[]): string {
    const avgResponseTime = memberData.reduce((sum, m) => sum + m.avgResponseTime, 0) / memberData.length;
    
    if (avgResponseTime < 4) return "Quick responders (under 4 hours)";
    if (avgResponseTime < 12) return "Same-day responders";
    return "Delayed responders (24+ hours)";
  }

  private analyzeSegmentRevenue(memberData: any[]): string {
    const totalRevenue = memberData.reduce((sum, m) => sum + m.revenue, 0);
    const avgRevenue = totalRevenue / memberData.length;
    
    return `Average $${Math.round(avgRevenue)} per subscriber`;
  }

  private generateSegmentSummary(memberData: any[], totalCount: number): string {
    const analysisSize = memberData.length;
    const mobileUsers = Math.round((memberData.filter(m => m.deviceType === 'mobile').length / analysisSize) * 100);
    const avgEngagement = Math.round(memberData.reduce((sum, m) => sum + m.opens, 0) / analysisSize);
    
    return `Segment of ${totalCount} subscribers with ${mobileUsers}% mobile users and average ${avgEngagement} email opens`;
  }

  private generateSegmentRecommendations(memberData: any[]): string[] {
    const recommendations = [];
    const mobilePercent = memberData.filter(m => m.deviceType === 'mobile').length / memberData.length;
    const avgEngagement = memberData.reduce((sum, m) => sum + m.opens, 0) / memberData.length;
    const avgResponseTime = memberData.reduce((sum, m) => sum + m.avgResponseTime, 0) / memberData.length;
    
    if (mobilePercent > 0.7) {
      recommendations.push("Optimize emails for mobile viewing");
    }
    if (avgEngagement > 12) {
      recommendations.push("High engagement - ideal for premium content");
    }
    if (avgResponseTime < 4) {
      recommendations.push("Quick responders - good for time-sensitive offers");
    }
    if (avgEngagement < 5) {
      recommendations.push("Consider re-engagement campaign");
    }
    
    return recommendations;
  }

  // AI segment generation methods
  private generateHighEngagementSegment(data: any[]): AutoGeneratedSegment {
    const highEngagers = data.filter(d => d.opens > 12 && d.clicks > 3);
    
    return {
      name: "High Engagement Champions",
      description: "Subscribers who consistently open and click emails",
      criteria: [
        { attribute: "sharpsend_total_opens", operator: "gte", value: 12 },
        { attribute: "sharpsend_total_clicks", operator: "gte", value: 3 }
      ],
      expectedSize: highEngagers.length,
      value: "Perfect for premium content and product announcements",
      insights: [
        "Opens emails within hours of delivery",
        "Clicks through to read full content",
        "Most likely to convert on offers"
      ]
    };
  }

  private generateMobileFirstSegment(data: any[]): AutoGeneratedSegment {
    const mobileUsers = data.filter(d => d.deviceType === 'mobile');
    
    return {
      name: "Mobile-First Readers",
      description: "Subscribers who primarily read on mobile devices",
      criteria: [
        { attribute: "sharpsend_device_preference", operator: "eq", value: "mobile" }
      ],
      expectedSize: mobileUsers.length,
      value: "Requires mobile-optimized content and shorter formats",
      insights: [
        "Reads emails on phone or tablet",
        "Prefers concise, scannable content",
        "Often engages during commute hours"
      ]
    };
  }

  private generateEarlyResponderSegment(data: any[]): AutoGeneratedSegment {
    const earlyResponders = data.filter(d => d.avgResponseTime < 2);
    
    return {
      name: "Early Bird Responders",
      description: "Subscribers who engage immediately after email delivery",
      criteria: [
        { attribute: "sharpsend_avg_response_time", operator: "lt", value: 2 }
      ],
      expectedSize: earlyResponders.length,
      value: "Ideal for breaking news and time-sensitive content",
      insights: [
        "Checks email frequently throughout the day",
        "Responds to emails within 2 hours",
        "Perfect audience for urgent announcements"
      ]
    };
  }

  private generateTechEnthusiastSegment(data: any[]): AutoGeneratedSegment {
    const techReaders = data.filter(d => d.contentCategories.includes('tech'));
    
    return {
      name: "Tech Enthusiasts",
      description: "Subscribers interested in technology and innovation content",
      criteria: [
        { attribute: "sharpsend_content_tech", operator: "eq", value: true }
      ],
      expectedSize: techReaders.length,
      value: "High-value audience for tech-related products and services",
      insights: [
        "Actively engages with technology content",
        "Likely early adopters of new tools",
        "Responds well to innovation-focused messaging"
      ]
    };
  }

  private generateFinanceReaderSegment(data: any[]): AutoGeneratedSegment {
    const financeReaders = data.filter(d => d.contentCategories.includes('finance'));
    
    return {
      name: "Finance & Investment Focused",
      description: "Subscribers who engage with financial and market content",
      criteria: [
        { attribute: "sharpsend_content_finance", operator: "eq", value: true }
      ],
      expectedSize: financeReaders.length,
      value: "Prime audience for investment products and financial services",
      insights: [
        "Regularly reads financial news",
        "Interested in market analysis",
        "Potential customers for investment tools"
      ]
    };
  }

  private generateNewsJunkieSegment(data: any[]): AutoGeneratedSegment {
    const newsReaders = data.filter(d => d.contentCategories.includes('news') && d.opens > 15);
    
    return {
      name: "News Junkies",
      description: "Heavy consumers of news and current events",
      criteria: [
        { attribute: "sharpsend_content_news", operator: "eq", value: true },
        { attribute: "sharpsend_total_opens", operator: "gte", value: 15 }
      ],
      expectedSize: newsReaders.length,
      value: "Excellent for breaking news and current events content",
      insights: [
        "Consumes news content daily",
        "High engagement with current events",
        "Values timely, accurate information"
      ]
    };
  }

  private generateWeekendReaderSegment(data: any[]): AutoGeneratedSegment {
    // Simulate weekend behavior analysis
    const weekendReaders = data.filter(d => Math.random() > 0.7); // Mock data
    
    return {
      name: "Weekend Warriors",
      description: "Subscribers who primarily engage on weekends",
      criteria: [
        { attribute: "sharpsend_weekend_engagement", operator: "eq", value: true }
      ],
      expectedSize: weekendReaders.length,
      value: "Perfect timing for weekend-specific content and offers",
      insights: [
        "Peak engagement on Saturday and Sunday",
        "Has more time for longer content",
        "Good audience for leisure-related offers"
      ]
    };
  }

  private generateClickerSegment(data: any[]): AutoGeneratedSegment {
    const clickers = data.filter(d => d.clicks > 5 && d.opens > 0);
    
    return {
      name: "Active Link Clickers",
      description: "Subscribers who frequently click through to read more",
      criteria: [
        { attribute: "sharpsend_total_clicks", operator: "gte", value: 5 }
      ],
      expectedSize: clickers.length,
      value: "High conversion potential for call-to-action campaigns",
      insights: [
        "Actively clicks links in emails",
        "Interested in learning more beyond email content",
        "Strong conversion potential"
      ]
    };
  }

  private generateLurkerSegment(data: any[]): AutoGeneratedSegment {
    const lurkers = data.filter(d => d.opens > 8 && d.clicks < 2);
    
    return {
      name: "Engaged Lurkers",
      description: "Subscribers who read emails but rarely click links",
      criteria: [
        { attribute: "sharpsend_total_opens", operator: "gte", value: 8 },
        { attribute: "sharpsend_total_clicks", operator: "lt", value: 2 }
      ],
      expectedSize: lurkers.length,
      value: "Need compelling calls-to-action to increase engagement",
      insights: [
        "Reads email content thoroughly",
        "Rarely clicks through to external content",
        "May prefer self-contained information"
      ]
    };
  }

  private generateHighValueSegment(data: any[]): AutoGeneratedSegment {
    const highValue = data.filter(d => d.revenue > 500);
    
    return {
      name: "High-Value Subscribers",
      description: "Premium subscribers with high lifetime value",
      criteria: [
        { attribute: "sharpsend_lifetime_value", operator: "gte", value: 500 }
      ],
      expectedSize: highValue.length,
      value: "VIP treatment and exclusive content opportunities",
      insights: [
        "High lifetime customer value",
        "Likely premium subscription holders",
        "Worth investing in retention efforts"
      ]
    };
  }

  private generatePotentialUpgradeSegment(data: any[]): AutoGeneratedSegment {
    const potentialUpgrades = data.filter(d => d.opens > 10 && d.revenue < 100 && d.clicks > 2);
    
    return {
      name: "Upgrade Candidates",
      description: "Engaged subscribers with low spend - upgrade potential",
      criteria: [
        { attribute: "sharpsend_total_opens", operator: "gte", value: 10 },
        { attribute: "sharpsend_lifetime_value", operator: "lt", value: 100 },
        { attribute: "sharpsend_total_clicks", operator: "gte", value: 2 }
      ],
      expectedSize: potentialUpgrades.length,
      value: "Prime targets for upgrade campaigns and premium offers",
      insights: [
        "High engagement but low spending",
        "Shows strong interest in content",
        "Likely to respond to upgrade offers"
      ]
    };
  }
}